{"meta":{"title":"Estella","subtitle":"Estellaの博客","description":"本科 | 计算机科学与技术","author":"Estella","url":"https://WXQ777.github.io","root":"/"},"pages":[{"title":"about","date":"2021-06-18T02:44:53.000Z","updated":"2021-06-18T02:45:17.109Z","comments":true,"path":"about/index.html","permalink":"https://wxq777.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-06-18T02:43:48.000Z","updated":"2021-06-18T02:44:16.750Z","comments":true,"path":"tags/index.html","permalink":"https://wxq777.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-06-18T02:42:37.000Z","updated":"2021-06-18T02:43:24.188Z","comments":true,"path":"categories/index.html","permalink":"https://wxq777.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-06-18T02:46:21.000Z","updated":"2021-06-18T02:46:43.250Z","comments":true,"path":"friends/index.html","permalink":"https://wxq777.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-06-18T02:45:31.000Z","updated":"2021-06-18T10:35:53.027Z","comments":true,"path":"contact/index.html","permalink":"https://wxq777.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Estellaの友链信息 博客名称: Estellaの博客 博客网址: https://wxq777.github.io/ 博客介绍: 知识面决定攻击面，知识链决定攻击深度！"},{"title":"","date":"2021-06-18T11:29:25.010Z","updated":"2021-06-18T11:29:25.010Z","comments":true,"path":"404.html","permalink":"https://wxq777.github.io/404.html","excerpt":"","text":"title: 404date: 2021-06-18 16:41:10type: “404”layout: “404”description: “Oops～，我崩溃了！找不到你想要的页面 :(“"}],"posts":[{"title":"1.排序算法","slug":"1.排序算法","date":"2021-06-18T12:25:37.183Z","updated":"2021-06-18T12:45:56.651Z","comments":true,"path":"2021/06/18/1.排序算法/","link":"","permalink":"https://wxq777.github.io/2021/06/18/1.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"1、桶排序基本思想：对于输入的数据（大小范围为0~max），创建0到max个桶，第一步装桶：遍历数据，将与元素值相等的桶计数加1；第二步输出：出现了几次就将桶的编号打印几次 C语言代码：例1：1234567891011121314151617181920212223242526272829/*小哼的班上只有 5 个同学，这 5 个同学分别考了 5 分、3 分、5 分、2 分和 8 分，哎考得真是惨不忍睹（满分是 10 分）。接下来将分数进行从大到小排序，排序后是 8 5 5 3 2。你有没有什么好方法编写一段程序，让计算机随机读入 5 个数然后将这5 个数从大到小输出？*/#include &lt;stdio.h&gt;int main()&#123; int a[11],i,j,t; //for(i=0;i&lt;=10;i++) 从小到大排序 for(i=10;i&gt;=0;i--) //从大到小排序 a[i]=0; //初始化为0 for(i=1;i&lt;=5;i++) //循环读入五个数 &#123; scanf(&quot;%d&quot;,&amp;t); //把每一个数读到变量t中 a[t]++; //进行计数 &#125; for(i=10;i&gt;=0;i--) //依次判断a[0]~a[10] for(j=1;j&lt;=a[i];j++) //出现了几次就打印几次 printf(&quot;%d&quot;,i); getchar();getchar(); //这里的getchar();用来暂停程序，以便查看程序输出的内容 //也可以用system(&quot;pause&quot;);等来代替 return 0;&#125; 例2：1234567891011121314151617181920212223242526272829/*尝试一下输入 n 个 0~1000 之间的整数，将它们从大到小排序。提醒一下， 如果需要对数据范围在 0~1000 之间的整数进行排序，我们需要 1001 个桶，来表示 0~1000之间每一个数出现的次数，这一点一定要注意。另外，此处的每一个桶的作用其实就是“标记”每个数出现的次数，因此我喜欢将之前的数组 a 换个更贴切的名字 book（book 这个单词有记录、标记的意思），代码实现如下*/#include&lt;stdio.h&gt;int main()&#123; int book[1001],i,j,t,n; for (i=1000;i&gt;=0;i--) book[i]=0; scanf(&quot;%d&quot;,&amp;n); //输入一个数n，表示接下来有n个数 for (i=1;i&lt;=n;i++)//循环读入n个数，并进行桶排序 &#123; scanf(&quot;%d&quot;,&amp;t);//把每一个数读到变量t中 book[t]++;//进行计数，对编号为t的桶放一个小旗子 &#125; for (i=1000;i&gt;=0;i--)//依次判断编号1000~0的桶 for(j=1;j&lt;=book[i];j++)//出现了几次就将桶的编号打印几次 printf(&quot;%d &quot;,i); return 0;&#125; 时间复杂度：O(M+N) 缺点：①最终输 出的也仅仅是分数，但没有对人本身进行排序。也就是说，并不知道排序后的分数 原本对应着哪一个人！②它很浪费空间！如果要排序5个0~90000000之间的数，就要创建90000001个桶。 2、冒泡排序基本思想：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换 过来。 总结：如果有 n 个数进行排序，只需将 n-1 个数归位，也就是说要进行 n-1 趟操作。而“每一趟”都需要从第 1 位开始进行相邻两个数的比较，将较小的一个数放 在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一 个尚未归位的数，已经归位的数则无需再进行比较 代码1：12345678910111213141516171819202122232425262728293031323334353637383940/*冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。最后我们总结一下：如果有 n 个数进行排序，只需将 n-1 个数归位，也就是说要进行n-1 趟操作。而“每一趟”都需要从第 1 位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一个尚未归位的数，已经归位的数则无需再进行比较（已经归位的数你还比较个啥，浪费表情）*/#include &lt;stdio.h&gt;int main()&#123; int a[100],i,j,t,n; scanf(&quot;%d&quot;,&amp;n); //输入一个数n，表示接下来有n个数 for(i=1;i&lt;=n;i++) //循环读入n个数到数组a中 &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; //冒泡排序的核心部分 for(i=1;i&lt;=n-1;i++) //n个数排序，只用进行n-1趟 &#123; for(j=1;j&lt;=n-i;j++)//从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了 &#123; if(a[j]&lt;a[j+1]) //比较大小并交换 &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; for(i=1;i&lt;=n;i++) //输出结果 printf(&quot;%d &quot;,a[i]); return 0;&#125; 代码2：12345678910111213141516171819202122232425262728293031323334353637383940414243/*现在分别有 5 个人的名字和分数：huhu 5 分、haha 3 分、xixi 5 分、hengheng 2 分和 gaoshou 8 分。请按照分数从高到低，输出他们的名字。即应该输出 gaoshou、huhu、xixi、haha、hengheng。*/#include &lt;stdio.h&gt;struct student&#123; char name[21]; char score;&#125;;//这里创建了一个结构体用来存储姓名和分数int main()&#123; struct student a[100],t; int i,j,n; scanf(&quot;%d&quot;,&amp;n); //输入一个数n，表示接下来有n个数 for(i=1;i&lt;=n;i++) //循环读入n个人名和分数 &#123; scanf(&quot;%s %d&quot;,a[i].name,&amp;a[i].score); &#125; //冒泡排序的核心部分---按分数从高到低进行排序 for(i=1;i&lt;=n-1;i++) //n个数排序，只用进行n-1趟 &#123; for(j=1;j&lt;=n-i;j++) //从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了 &#123; if(a[j].score&lt;a[j+1].score) //比较分数并交换 &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; for(i=1;i&lt;=n;i++) //输出人名 printf(&quot;%s\\n&quot;,a[i].name); return 0;&#125; 冒泡排序的核心部分是双重嵌套循环。 冒排序的时间复杂度是 O(N^2 ) 快速排序基本思想：“二分”思想。从待排序序列中选取一个记录的基准数为key，通过一趟排序将待排序列分割成两部分，把这一组数分为小于key的一小组数，和大于key的另一小组数。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 选择基准数（key）的方式:①取头尾位置值法1234int SelectKey1(int a[],int lift,int right)&#123; return a[right];//选择选取序列的最后一个元素作为基准&#125; 分析：如果待排序序列是随机的，这种方法下的处理时间是可以接受的。如果待排序序列已经有序时，此时对快排的分割是非常不利的，因为每次划分只能使待排序序列减一。 ②随机选取基准法12345678 int SelectKey2(int a[],int lift,int right)&#123; srand((unsigned)time(NULL)); int key = rand() % (right - lift) + left; swap(&amp;a[key],&amp;a[right]); //互换一下位置，为了调用划分函数时与上面方式下的代码保持统一 return a[right];&#125; 分析：当待排序序列都相等时，此中情况下排序的时间复杂度仍为O(N^2)，但是，随机化快速排序对于绝大多数排序序列达到 O(nlogn）的期望时间复杂度。 ③三数取中法(优化有序的数据)一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准。 1234567891011121314int SelectKey3(int a[], int left, int right)&#123; int mid = left + ((right - left) &gt;&gt; 1); //计算数组中间的元素的下标 if (a[left] &lt; a[mid]) swap(&amp;a[left], &amp;a[mid]); if (a[left] &lt; a[right]) swap(&amp;a[left], &amp;a[right]); if (a[mid] &gt; a[right]) swap(&amp;a[mid], &amp;a[right]); //a[left]&gt;=a[right]&gt;=a[mid] //分割时可以直接使用right位置的元素作为基准，而不用改变分割函数了 return a[right];&#125; 分析： 使用三数中值分割法消除了预排序序列有序情况下造成的极大消耗，同时也是对随机数法下有可能出现的小概率事件的完善（当待排序序列有序的情况下随机数法仍然有可能给我们的基准是序列头尾的元素）。当待排序序列都相等时，此中情况下排序的时间复杂度仍为O(N^2)。 代码1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int a[101],n;//定义全局变量，这两个变量需要在子函数中使用void quicksort(int left,int right);int main()&#123; int i,j,t; //读入数据 scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); quicksort(1,n);//快速排序调用 //输出排序后的结果 for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); getchar();getchar(); return 0;&#125;void quicksort(int left,int right)&#123; int i,j,t,temp; if(left&gt;right) return; temp=a[left];//temp中存的就是基准数 i=left; j=right; while (i!=j) &#123; //顺序很重要，要先从右往左找 while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再从左往右找 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j)//当哨兵i和哨兵j没有相遇时 &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程&#125; https://blog.csdn.net/z_x_m_m_q/article/details/82220884?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-.pc_search_result_before_js&amp;spm=1018.2226.3001.4187 小哼买书例题：输入有 2 行，第 1 行为一个正整数，表示有 n 个同学参与调查（n≤100）。第 2 行有 n个用空格隔开的正整数，为每本图书的ISBN 号（假设图书的 ISBN 号在 1~1000 之间）。输出也是 2 行，第 1 行为一个正整数 k，表示需要买多少本书。第 2 行为 k 个用空格隔开的正整数，为从小到大已排好序的需要购买的图书的 ISBN 号 1.先去重再排序—桶排序12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int a[1001],n,i,t; for(i=1;i&lt;=1000;i++) a[i]=0;//初始化 scanf(&quot;%d&quot;,&amp;n);//读入n for(i=1;i&lt;=n;i++)//循环读入n个图书的ISBN号 &#123; scanf(&quot;%d&quot;,&amp;t);//把每一个ISBN号读到变量t中 a[t]=1;//标记出现过得ISBN号 &#125; for(i=1;i&lt;=1000;i++) //依次判断1~1000这个1000个桶 &#123; if(a[i]==1)//如果这个ISBN号出现过则打印出来 printf(&quot;%d &quot;,i); &#125; getchar();getchar(); return 0; &#125; 2.先排序再去重–冒泡排序或者快速排序接下来，要在输出的时候去掉重复的。因为我们已经排好序，所以相同的数都会紧挨在一起。只要在输出的时候，预先判断一下当前这个数 a[i]与前面一个数 a[i-1]是否相同。如果相同则表示这个数之前已经输出过了，不用再次输出；不同则表示这个数是第一次出现，需要输出这个数。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt; int main() &#123; int a[101],n,i,j,t; scanf(&quot;%d&quot;,&amp;n); //读入n for(i=1;i&lt;=n;i++) //循环读入n个图书ISBN号 &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; //开始冒泡排序 for(i=1;i&lt;=n-1;i++) &#123; for(j=1;j&lt;=n-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; printf(&quot;%d &quot;,a[1]); //输出第1个数 for(i=2;i&lt;=n;i++) //从2循环到n &#123; if( a[i] != a[i-1] ) //如果当前这个数是第一次出现则输出 printf(&quot;%d &quot;,a[i]); &#125; getchar();getchar(); return 0; &#125;","categories":[],"tags":[]},{"title":"Hello World！","slug":"hello-world","date":"2021-06-17T16:27:42.319Z","updated":"2021-06-18T11:19:51.087Z","comments":true,"path":"2021/06/18/hello-world/","link":"","permalink":"https://wxq777.github.io/2021/06/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}