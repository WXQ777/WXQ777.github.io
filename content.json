{"meta":{"title":"Estella","subtitle":"Estellaの博客","description":"本科 | 计算机科学与技术","author":"Estella","url":"https://WXQ777.github.io","root":"/"},"pages":[{"title":"about","date":"2021-06-18T02:44:53.000Z","updated":"2021-06-18T02:45:17.109Z","comments":true,"path":"about/index.html","permalink":"https://wxq777.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-06-18T02:43:48.000Z","updated":"2021-06-18T02:44:16.750Z","comments":true,"path":"tags/index.html","permalink":"https://wxq777.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-06-18T02:42:37.000Z","updated":"2021-06-18T02:43:24.188Z","comments":true,"path":"categories/index.html","permalink":"https://wxq777.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-06-18T02:46:21.000Z","updated":"2021-06-18T02:46:43.250Z","comments":true,"path":"friends/index.html","permalink":"https://wxq777.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2021-06-18T02:45:31.000Z","updated":"2021-06-18T10:35:53.027Z","comments":true,"path":"contact/index.html","permalink":"https://wxq777.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Estellaの友链信息 博客名称: Estellaの博客 博客网址: https://wxq777.github.io/ 博客介绍: 知识面决定攻击面，知识链决定攻击深度！"},{"title":"","date":"2021-06-18T11:29:25.010Z","updated":"2021-06-18T11:29:25.010Z","comments":true,"path":"404.html","permalink":"https://wxq777.github.io/404.html","excerpt":"","text":"title: 404date: 2021-06-18 16:41:10type: “404”layout: “404”description: “Oops～，我崩溃了！找不到你想要的页面 :(“"}],"posts":[{"title":"2.队列、栈、链表","slug":"2.栈、队列、链表","date":"2021-07-03T04:04:17.598Z","updated":"2021-07-03T04:17:53.090Z","comments":true,"path":"2021/07/03/2.栈、队列、链表/","link":"","permalink":"https://wxq777.github.io/2021/07/03/2.%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8/","excerpt":"","text":"1、队列1.1、解密QQ号小哈给了小哼一串加密过的数字，同时小哈也告诉了小哼解密规则。规则是这样的：首先将第 1 个数删除，紧接着将第 2 个数放到 这串数的末尾，再将第 3 个数删除并将第 4 个数放到这串数的末尾，再将第 5 个数删除…… 直到剩下最后一个数，将最后一个数也删除。按照刚才删除的顺序，把这些删除的数连在一 起就是小哈的 QQ 啦。现在你来帮帮小哼吧。小哈给小哼加密过的一串数是“6 3 1 7 5 8 9 2 4”。 在这里，我将引入两个整型变量 head 和 tail。head 用来记录队列的队首（即第一位）， tail 用来记录队列的队尾（即最后一位）的下一个位置。你可能会问：为什么 tail 不直接记 录队尾，却要记录队尾的下一个位置呢？这是因为当队列中只剩下一个元素时，队首和队尾重合会带来一些麻烦。我们这里规定队首和队尾重合时，队列为空。 1.2 、法一12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; int q[102]=&#123;0,6,3,1,7,5,8,9,2,4&#125;,head,tail; //初始化队列 head=1; tail=10;//队列中已经有9个元素了，tail指向队尾的后一个位置 while(head&lt;tail)//当队列不为空的时候执行循环 &#123; //打印队首并将队首出队 printf(&quot;%d &quot;,q[head]); head++; //先将新队首的数添加到队尾 q[tail]=q[head]; tail++; //再将队首出队 head++; &#125; return 0;&#125; 小结 队列（线性结构）——先进先出。它只允许在队列的首部（head）进行删除操作，这称为“出队”，而在队列 的尾部（tail）进行插入操作，这称为“入队”。当队列中没有元素时（即 head==tail），称为 空队列。 队首和队尾重合时，队列为空 在队首删除一个数的操作是 head++ 在队尾增加一个数（假设这个数是 x）的操作是 q[tail]=x;tail++; 1.3、法二定义一个结构体类型——我们通常将其放在 main 函数的外面，请注意结构体的定 义末尾有个 ; 号。 123456struct queue &#123; int data[100];//队列的主体，用来存储内容 int head;//队首 int tail;//队尾&#125;; 定义结构体变量——注意 struct queue 需要整体使用，不能直接写 queue q; 1struct queue q; 访问结构体变量的内部成员——可以使用.号，它叫做成员运算符或者点号运算符 123q.head=1; q.tail=1; scanf(&quot;%d&quot;,&amp;q.data[q.tail]); 代码如下：使用结构体来实现的队列操作。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;struct queue&#123; int date[100];//队列的主体，用来存储内容 int head;//队首 int tail;//队尾&#125;;int main()&#123; struct queue q; int i; //初始化队列 q.head=1; q.tail=1; for(i=1;i&lt;=9;i++) &#123; //依次向队列插入9个数 scanf(&quot;%d&quot;,&amp;q.date[q.tail]); q.tail++; &#125; while(q.head&lt;q.tail)//当队列不为空的时候执行循环 &#123; //打印队首并将队首出队 printf(&quot;%d &quot;,q.date[q.head]); q.head++; //先将新队首的数添加到队尾 q.date[q.tail]=q.date[q.head]; q.tail++; //再将队首出队 q.head++; &#125; return 0;&#125; 2、栈–解密回文题目：“xyzyx”是一个回文字符串，所谓回文字符 串就是指正读反读均相同的字符序列，如“席主席”、“记书记”、“aha”和“ahaha”均是回 文，但“ahah”不是回文。通过栈这个数据结构我们将很容易判断一个字符串是否为回文。 首先我们需要读取这行字符串，并求出这个字符串的长度。 1234char a[101]; int len; gets(a); len=strlen(a); 如果一个字符串是回文的话，那么它必须是中间对称的，我们需要求中点，即： 1mid=len/2-1; 将 mid 之前的字符依次全部入栈。初始化栈很简单，top=0;就可以了。入栈的操作是top++; s[top]=x; （假设需要入栈的字符暂存在字符变量x中），其实可以简写为s[++top]=x; 1234for(i=0;i&lt;=mid;i++) &#123; s[++top]=a[i]; &#125; 将当前栈中的字符依次出栈，看看是否能与 mid 之后 的字符一一匹配，如果都能匹配则说明这个字符串是回文字符串，否则这个字符串就不是回文字符串。最后如果 top 的值为 0，就说明栈内所有的字符都被一一匹配了，那么这个字符串就是 回文字符串。 123456789101112for(i=mid+1;i&lt;=len-1;i++) &#123; if (a[i]!=s[top]) &#123; break; &#125; top--; &#125; if(top==0) printf(&quot;YES&quot;); else printf(&quot;NO&quot;); 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char a[101],s[101]; int i,len,mid,next,top; gets(a);//读入一行字符串 len=strlen(a);//求字符串的长度 mid=len/2-1;//求字符串的中点 top=0;//栈的初始化 //将mid前的字符依次入栈 for(i=0;i&lt;=mid;i++) s[++top]=a[i]; //判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 if(len%2==0) next=mid+1; else next=mid+2; //开始匹配 for(i=next;i&lt;=len-1;i++) &#123; if(a[i]!=s[top]) break; top--; &#125; //如果top的值为0，则说明栈内所有的字符都被一一 匹配了 if(top==0) printf(&quot;YES&quot;); else printf(&quot;NO&quot;); return 0;&#125; 可以输入以下数据进行验证。 1ahaha 运行结果是： 1YES 小结： 栈——后进先出 栈限定为只能在一端进行插入和删除操作 栈的实现也很简单，只需要一个一维数组和一个指向栈顶的变量 top 就可以了。我们通过 top 来对栈进行插入和删除操作 3、纸牌游戏——小猫钓鱼​ 星期天小哼和小哈约在一起玩桌游，他们正在玩一个非常古怪的扑克游戏——“小猫钓 鱼”。游戏的规则是这样的：将一副扑克牌平均分成两份，每人拿一份。小哼先拿出手中的 第一张扑克牌放在桌上，然后小哈也拿出手中的第一张扑克牌，并放在小哼刚打出的扑克牌 的上面，就像这样两人交替出牌。出牌时，如果某人打出的牌与桌上某张牌的牌面相同，即可将两张相同的牌及其中间所夹的牌全部取走，并依次放到自己手中牌的末尾。当任意一人 手中的牌全部出完时，游戏结束，对手获胜。 假如游戏开始时，小哼手中有 6 张牌，顺序为 2 4 1 2 5 6，小哈手中也有 6 张牌，顺序 为 3 1 3 5 6 4，最终谁会获胜呢？现在你可以拿出纸牌来试一试。接下来请你写一个程序来 自动判断谁将获胜。这里我们做一个约定，小哼和小哈手中牌的牌面只有 1~9。 解析：小哼有两种操作，分别是出牌和赢牌。这恰好对应队列的两个操作，出牌就是出队，赢牌就是入队。小哈的操作和小哼是一样的。而桌子就是一个栈，每打出一张牌放到桌上就相当于入栈。当有人赢牌的时候，依次将牌从桌上 拿走，这就相当于出栈。所以我们需要两个队列、一个栈来模拟整个游戏 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;//1.创建一个结构体用来实现队列struct queue&#123; int date[1000];//存储队列中的元素 int head;//存储队头 int tail;//存储队尾&#125;;//2.创建一个结构体用来实现栈struct stack&#123; int date[10];//存储栈中的元素（桌面最多可能有9张牌，但数组下标从0开始，所以数组大小为10） int top;//存储栈顶&#125;;int main()&#123; //3.定义变量 struct queue q1,q2;//q1为小哼手中的牌，q2为小哈手中的牌 struct stack s;//s为桌上的牌 int book[10]; int i,t; //4.初始化队列-两人手中都还没牌 q1.head=1; q1.tail=1; q2.head=1; q2.tail=1; //初始化栈-最开始桌上也没牌 s.top=0; //初始化用来标记的数组，用来标记哪些牌已经在桌上 for(i=1;i&lt;=9;i++) book[i]=0; //5.依次向队列插入6个数 //小哼手上的6张牌 for(i=1;i&lt;=6;i++) &#123; scanf(&quot;%d&quot;,&amp;q1.date[q1.tail]);//读入一个数到队尾 q1.tail++;//队尾往后挪一位 &#125; //小哈手上的6张牌 for(i=1;i&lt;=6;i++) &#123; scanf(&quot;%d&quot;,&amp;q2.date[q2.tail]); q2.tail++; &#125; while(q1.head&lt;q1.tail &amp;&amp; q2.head&lt;q2.tail)//当队列不为空的时候执行循环 &#123; t=q1.date[q1.head];//小哼先亮出一张牌 //判断小哼当前打出的牌是否能赢牌 if(book[t]==0)//表明桌上没有牌面为t的牌 &#123; //小哼此轮没有赢牌 q1.head++;//小哼已经打出一张牌，所以要把打出的牌出队 s.top++; s.date[s.top]=t;//再把打出的牌放到桌上，即入栈 book[t]=1;//标记桌上现在已经有牌面为t的牌 &#125; else &#123; //小哼此轮可以赢牌 q1.head++;//小哼已经打出一张牌，所以要把打出的牌出队 q1.date[q1.tail]=t;//紧接着把打出的牌放到手中牌的末尾 q1.tail++; while(s.date[s.top]!=t)//把桌上可以赢得的牌依次放到手中牌的末尾 &#123; book[s.date[s.top]]=0;//取消标记 q1.date[q1.tail]=s.date[s.top];//依次放入队尾 q1.tail++; s.top--;//栈中少了一张牌，所以栈顶要减1 &#125; &#125; t=q2.date[q2.head];//小哈出一张牌 //判断小哈当前打出的牌是否能赢牌 if(book[t]==0)//表明桌上没有牌面为t的牌 &#123; //小哈此轮没有赢牌 q2.head++;//小哈已经打出一张牌，所以要把打出的牌出队 s.top++; s.date[s.top]=t;//再把打出的牌放到桌上，即入栈 book[t]=1;//标记桌上现在已经有牌面为t的牌 &#125; else &#123; //小哈此轮可以赢牌 q2.head++;//小哈已经打出一张牌，所以要把打出的牌出队 q2.date[q2.tail]=t;//紧接着把打出的牌放到手中牌的末尾 q2.tail++; while(s.date[s.top]!=t)//把桌上可以赢得的牌依次放到手中牌的末尾 &#123; book[s.date[s.top]]=0;//取消标记 q2.date[q2.tail]=s.date[s.top];//依次放入队尾 q2.tail++; s.top--;//栈中少了一张牌，所以栈顶要减1 &#125; &#125; &#125; if(q2.head==q2.tail) &#123; printf(&quot;小哼win\\n&quot;); printf(&quot;小哼当前手中的牌是&quot;); for(i=q1.head;i&lt;=q1.tail-1;i++) printf(&quot; %d&quot;,q1.date[i]); if(s.top&gt;0) //如果桌上有牌则依次输出桌上的牌 &#123; printf(&quot;\\n桌上的牌是&quot;); for(i=1;i&lt;=s.top;i++) printf(&quot; %d&quot;,s.date[i]); &#125; else printf(&quot;\\n桌上已经没有牌了&quot;); &#125; else &#123; printf(&quot;小哈win\\n&quot;); printf(&quot;小哈当前手中的牌是&quot;); for(i=q2.head;i&lt;=q2.tail-1;i++) printf(&quot; %d&quot;,q2.date[i]); if(s.top&gt;0) //如果桌上有牌则依次输出桌上的牌 &#123; printf(&quot;\\n桌上的牌是&quot;); for(i=1;i&lt;=s.top;i++) printf(&quot; %d&quot;,s.date[i]); &#125; else printf(&quot;\\n桌上已经没有牌了&quot;); &#125; return 0;&#125; 可以输入以下数据进行验证。 12 4 1 2 5 6 3 1 3 5 6 4 运行结果是： 123小哼win 小哼当前手中的牌是 5 6 2 3 1 4 6 5 桌上的牌是 2 1 3 4 如果你设计一些测试数据来验证的话，会发现我们刚才的代码其实还是有问题的。比如 游戏可能无法结束。就是小哼和小哈可以永远玩下去，谁都无法赢得对方所有的牌。请你自己想一想如何解决游戏无法结束的问题。 4、链表有一串已经从小到大排好序的数 2 3 5 8 9 10 18 26 32。现需要往这串数中插入 6 使其得 到的新序列仍符合从小到大排列。如我们使用数组来实现这一操作，则需要将 8 和 8 后面的 数都依次往后挪一位，如下： 这样操作显然很耽误时间，如果使用链表则会快很多。此时如果需要在 8 前面插入一个 6，就只需像下图这样更改一下就可以了，而无需再将 8 及后面的数都依次往后挪一位。 那么如何实现链表呢？在 C 语言中可以使用指针和动态分配内存函数 malloc 来实现。 在C语言中*号有三个用途： 乘号，用作乘法运算，如4*5. 申明一个指针，在定义指针变量时使用，如int*p; 间接运算符，取得指针所指向的内存中的值，如printf(“%d”,*p); 回想一下，我们想在程序中存储一个整数 10，除了使用 int a;这种方式在内存中申请一 块区域来存储，还有另外一种动态存储方法。 1malloc(4); malloc 函数的作用就是从内存中申请分配指定字节大小的内存空间。上面这行代码就申 请了 4 个字节。如果你不知道 int 类型是 4 个字节的，还可以使用 sizeof(int)获取 int 类型所 占用的字节数，如下： 1malloc(sizeof(int)); 现在你已经成功地从内存中申请了 4 个字节的空间来准备存放一个整数，可是如何来 对这个空间进行操作呢？这里我们就需要用一个指针来指向这个空间，即存储这个空间的 首地址。 12int *p; p=(int *)malloc(sizeof(int)); 注意： malloc 函数的返回类型是 void * 类型。void * 表示未确定类型的指针。在 C 和 C++中，void * 类型可以强制转换为任何其他类型的指针。 当在程序中使用 malloc 函数时需要用到 stdlib.h 头文件。 现在我们可以通过指针 p 对刚才申请的 4 个字节的空间进行操作了，例如我们向 这个空间中存入整数 10，如下： 12345678910#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int *p; //定义一个指针p p=(int *)malloc(sizeof(int)); //指针p获取动态分配的内存空间地址 *p=10; //向指针p所指向的内存空间中存入10 printf(&quot;%d&quot;,*p); //输出指针p所指向的内存中的值 return 0; &#125; 运行结果是: 110 到这里你可能要问：为什么要用这么复杂的办法来存储数据呢？因为之前的方法，我们 必须预先准确地知道所需变量的个数，也就是说我们必须定义出所有的变量。比如我们定义 了 100 个整型变量，那么程序就只能存储 100 个整数，如果现在的实际情况是需要存储 101 个，那必须修改程序才可以。如果有一天你写的软件已经发布或者交付使用，却发现要存储 1000 个数才行，那就不得不再次修改程序，重新编译程序，发布一个新版本来代替原来的。 而有了 malloc 函数我们便可以在程序运行的过程中根据实际情况来申请空间。 首先我们来看一下，链表中的每一个结点应该如何存储。 每一个结点都由两个部分组成。左边的部分用来存放具体的数值，那么用一个整型变量 就可以；右边的部分需要存储下一个结点的地址，可以用指针来实现（也称为后继指针)。 如果这是第一个创建的结点，则将头指针指向这个结点。 如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点。 最后要将指针 q 也指向当前结点，因为待会儿临时指针 p 将会指向新创建的结点 1q=p;//指针q也指向当前结点 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node&#123; int date; struct node *next;&#125;;int main()&#123; struct node *head,*p,*q,*t; int i,n,a; scanf(&quot;%d&quot;,&amp;n); head = NULL;//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(&quot;%d&quot;,&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;date=a;//将数据存储到当前结点的date域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(&quot;%d &quot;,t-&gt;date); t=t-&gt;next;//继续下一个结点 &#125; return 0;&#125; 需要说明的一点是：上面这段代码没有释放动态申请的空间，虽然没有错误，但是这样 会很不安全，有兴趣的朋友可以去了解一下 free 命令 可以输入以下数据进行验证。 129 2 3 5 8 9 10 18 26 32 运行结果是： 12 3 5 8 9 10 18 26 32 接下来需要往链表中插入6 首先用一个临时指针 t 从链表的头部开始遍历。 1t=head;//从链表头部开始遍历 等到指针 t 的下一个结点的值比 6 大的时候，将 6 插入到中间。即 t-&gt;next-&gt;data 大于 6 时进行插入，代码如下。 12345678910111213scanf(&quot;%d&quot;,&amp;a);//读入待插入的数while(t!=NULL)//当没有到达链表尾部的时候循环&#123; if(t-&gt;next-&gt;data &gt; a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; p=(struct node *)malloc(sizeof(struct node));//动态申请一个空间，用来存放新增结点 p-&gt;data=a; p-&gt;next=t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点 t-&gt;next=p;//当前结点的后继指针指向新增结点 break;//插入完毕退出循环 &#125; t=t-&gt;next;//继续下一个结点&#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型struct node &#123; int data; struct node *next; &#125;; int main() &#123; struct node *head,*p,*q,*t; int i,n,a; scanf(&quot;%d&quot;,&amp;n); head = NULL;//头指针初始为空 for(i=1;i&lt;=n;i++)//循环读入n个数 &#123; scanf(&quot;%d&quot;,&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p=(struct node *)malloc(sizeof(struct node)); p-&gt;data=a;//将数据存储到当前结点的data域中 p-&gt;next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if(head==NULL) head=p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q=p;//指针q也指向当前结点 &#125; scanf(&quot;%d&quot;,&amp;a);//读入待插入的数 t=head;//从链表头部开始遍历 while(t!=NULL)//当没有到达链表尾部的时候循环 &#123; if(t-&gt;next-&gt;data &gt; a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; p=(struct node *)malloc(sizeof(struct node));//动态申请一个空间，用来存放新增结点 p-&gt;data=a; p-&gt;next=t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点 t-&gt;next=p;//当前结点的后继指针指向新增结点 break;//插入完毕退出循环 &#125; t=t-&gt;next;//继续下一个结点 &#125; //输出链表中的所有数 t=head; while(t!=NULL) &#123; printf(&quot;%d &quot;,t-&gt;data); t=t-&gt;next;//继续下一个结点 &#125; return 0; &#125; 可以输入以下数据进行验证。 1239 2 3 5 8 9 10 18 26 32 6 运行结果是 12 3 5 6 8 9 10 18 26 32 5、模拟链表除了上节的指针，链表还有另外一种使用数组来实现的方式，叫做模拟链表 链表中的每一个结点只有两个部分。我们可以用一个数组 data 来存储每序列中的每一个 数。那每一个数右边的数是谁，这一点该怎么解决呢？上一节中是使用指针来解决的，这里 我们只需再用一个数组right来存放序列中每一个数右边的数是谁就可以了，具体怎么做呢？ 上图的两个数组中，第一个整型数组 data 是用来存放序列中具体数字的，另外一个整型 数组 right 是用来存放当前序列中每一个元素右边的元素在数组 data 中位置的。例如 right[1] 的值为 2，就表示当前序列中 1 号元素右边的元素存放在 data[2]中；如果是 0，例如 right[9] 的值为 0，就表示当前序列中 9 号元素的右边没有元素。 现在需要在 8 前面插入一个 6，只需将 6 直接存放在数组 data 的末尾即 data[10]=6。接下 来只需要将right[3]改为10，表示新序列中3号元素右边的元素存放在data[10]中。再将right[10] 改为 4，表示新序列中 10 号元素右边的元素存放在 data[4]中。这样我们通过 right 数组就可以 从头到尾遍历整个序列了（序列的每个元素的值存放在对应的数组 data 中），如下。 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; int main() &#123; int data[101],right[101]; int i,n,t,len; //读入已有的数 scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;data[i]); len=n; //初始化数组right for(i=1;i&lt;=n;i++) &#123; if(i!=n) right[i]=i+1; else right[i]=0; &#125; //直接在数组data的末尾增加一个数 len++; scanf(&quot;%d&quot;,&amp;data[len]); //从链表的头部开始遍历 t=1; while(t!=0) &#123; if(data[right[t]]&gt;data[len])//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; right[len]=right[t];//新插入数的下一个结点标号等于当前结点的下一个结点编号 right[t]=len;//当前结点的下一个结点编号就是新插入数的编号 break;//插入完成跳出循环 &#125; t=right[t]; &#125; //输出链表中所有的数 t=1; while(t!=0) &#123; printf(&quot;%d &quot;,data[t]); t=right[t]; &#125; return 0; &#125; 可以输入以下数据进行验证。 1239 2 3 5 8 9 10 18 26 32 6 运行结果是： 12 3 5 6 8 9 10 18 26 32","categories":[],"tags":[]},{"title":"1.排序算法","slug":"1.排序算法","date":"2021-06-18T12:25:37.183Z","updated":"2021-06-18T12:45:56.651Z","comments":true,"path":"2021/06/18/1.排序算法/","link":"","permalink":"https://wxq777.github.io/2021/06/18/1.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"1、桶排序基本思想：对于输入的数据（大小范围为0~max），创建0到max个桶，第一步装桶：遍历数据，将与元素值相等的桶计数加1；第二步输出：出现了几次就将桶的编号打印几次 C语言代码：例1：1234567891011121314151617181920212223242526272829/*小哼的班上只有 5 个同学，这 5 个同学分别考了 5 分、3 分、5 分、2 分和 8 分，哎考得真是惨不忍睹（满分是 10 分）。接下来将分数进行从大到小排序，排序后是 8 5 5 3 2。你有没有什么好方法编写一段程序，让计算机随机读入 5 个数然后将这5 个数从大到小输出？*/#include &lt;stdio.h&gt;int main()&#123; int a[11],i,j,t; //for(i=0;i&lt;=10;i++) 从小到大排序 for(i=10;i&gt;=0;i--) //从大到小排序 a[i]=0; //初始化为0 for(i=1;i&lt;=5;i++) //循环读入五个数 &#123; scanf(&quot;%d&quot;,&amp;t); //把每一个数读到变量t中 a[t]++; //进行计数 &#125; for(i=10;i&gt;=0;i--) //依次判断a[0]~a[10] for(j=1;j&lt;=a[i];j++) //出现了几次就打印几次 printf(&quot;%d&quot;,i); getchar();getchar(); //这里的getchar();用来暂停程序，以便查看程序输出的内容 //也可以用system(&quot;pause&quot;);等来代替 return 0;&#125; 例2：1234567891011121314151617181920212223242526272829/*尝试一下输入 n 个 0~1000 之间的整数，将它们从大到小排序。提醒一下， 如果需要对数据范围在 0~1000 之间的整数进行排序，我们需要 1001 个桶，来表示 0~1000之间每一个数出现的次数，这一点一定要注意。另外，此处的每一个桶的作用其实就是“标记”每个数出现的次数，因此我喜欢将之前的数组 a 换个更贴切的名字 book（book 这个单词有记录、标记的意思），代码实现如下*/#include&lt;stdio.h&gt;int main()&#123; int book[1001],i,j,t,n; for (i=1000;i&gt;=0;i--) book[i]=0; scanf(&quot;%d&quot;,&amp;n); //输入一个数n，表示接下来有n个数 for (i=1;i&lt;=n;i++)//循环读入n个数，并进行桶排序 &#123; scanf(&quot;%d&quot;,&amp;t);//把每一个数读到变量t中 book[t]++;//进行计数，对编号为t的桶放一个小旗子 &#125; for (i=1000;i&gt;=0;i--)//依次判断编号1000~0的桶 for(j=1;j&lt;=book[i];j++)//出现了几次就将桶的编号打印几次 printf(&quot;%d &quot;,i); return 0;&#125; 时间复杂度：O(M+N) 缺点：①最终输 出的也仅仅是分数，但没有对人本身进行排序。也就是说，并不知道排序后的分数 原本对应着哪一个人！②它很浪费空间！如果要排序5个0~90000000之间的数，就要创建90000001个桶。 2、冒泡排序基本思想：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换 过来。 总结：如果有 n 个数进行排序，只需将 n-1 个数归位，也就是说要进行 n-1 趟操作。而“每一趟”都需要从第 1 位开始进行相邻两个数的比较，将较小的一个数放 在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一 个尚未归位的数，已经归位的数则无需再进行比较 代码1：12345678910111213141516171819202122232425262728293031323334353637383940/*冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。最后我们总结一下：如果有 n 个数进行排序，只需将 n-1 个数归位，也就是说要进行n-1 趟操作。而“每一趟”都需要从第 1 位开始进行相邻两个数的比较，将较小的一个数放在后面，比较完毕后向后挪一位继续比较下面两个相邻数的大小，重复此步骤，直到最后一个尚未归位的数，已经归位的数则无需再进行比较（已经归位的数你还比较个啥，浪费表情）*/#include &lt;stdio.h&gt;int main()&#123; int a[100],i,j,t,n; scanf(&quot;%d&quot;,&amp;n); //输入一个数n，表示接下来有n个数 for(i=1;i&lt;=n;i++) //循环读入n个数到数组a中 &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; //冒泡排序的核心部分 for(i=1;i&lt;=n-1;i++) //n个数排序，只用进行n-1趟 &#123; for(j=1;j&lt;=n-i;j++)//从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了 &#123; if(a[j]&lt;a[j+1]) //比较大小并交换 &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; for(i=1;i&lt;=n;i++) //输出结果 printf(&quot;%d &quot;,a[i]); return 0;&#125; 代码2：12345678910111213141516171819202122232425262728293031323334353637383940414243/*现在分别有 5 个人的名字和分数：huhu 5 分、haha 3 分、xixi 5 分、hengheng 2 分和 gaoshou 8 分。请按照分数从高到低，输出他们的名字。即应该输出 gaoshou、huhu、xixi、haha、hengheng。*/#include &lt;stdio.h&gt;struct student&#123; char name[21]; char score;&#125;;//这里创建了一个结构体用来存储姓名和分数int main()&#123; struct student a[100],t; int i,j,n; scanf(&quot;%d&quot;,&amp;n); //输入一个数n，表示接下来有n个数 for(i=1;i&lt;=n;i++) //循环读入n个人名和分数 &#123; scanf(&quot;%s %d&quot;,a[i].name,&amp;a[i].score); &#125; //冒泡排序的核心部分---按分数从高到低进行排序 for(i=1;i&lt;=n-1;i++) //n个数排序，只用进行n-1趟 &#123; for(j=1;j&lt;=n-i;j++) //从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了 &#123; if(a[j].score&lt;a[j+1].score) //比较分数并交换 &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; for(i=1;i&lt;=n;i++) //输出人名 printf(&quot;%s\\n&quot;,a[i].name); return 0;&#125; 冒泡排序的核心部分是双重嵌套循环。 冒排序的时间复杂度是 O(N^2 ) 快速排序基本思想：“二分”思想。从待排序序列中选取一个记录的基准数为key，通过一趟排序将待排序列分割成两部分，把这一组数分为小于key的一小组数，和大于key的另一小组数。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 选择基准数（key）的方式:①取头尾位置值法1234int SelectKey1(int a[],int lift,int right)&#123; return a[right];//选择选取序列的最后一个元素作为基准&#125; 分析：如果待排序序列是随机的，这种方法下的处理时间是可以接受的。如果待排序序列已经有序时，此时对快排的分割是非常不利的，因为每次划分只能使待排序序列减一。 ②随机选取基准法12345678 int SelectKey2(int a[],int lift,int right)&#123; srand((unsigned)time(NULL)); int key = rand() % (right - lift) + left; swap(&amp;a[key],&amp;a[right]); //互换一下位置，为了调用划分函数时与上面方式下的代码保持统一 return a[right];&#125; 分析：当待排序序列都相等时，此中情况下排序的时间复杂度仍为O(N^2)，但是，随机化快速排序对于绝大多数排序序列达到 O(nlogn）的期望时间复杂度。 ③三数取中法(优化有序的数据)一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准。 1234567891011121314int SelectKey3(int a[], int left, int right)&#123; int mid = left + ((right - left) &gt;&gt; 1); //计算数组中间的元素的下标 if (a[left] &lt; a[mid]) swap(&amp;a[left], &amp;a[mid]); if (a[left] &lt; a[right]) swap(&amp;a[left], &amp;a[right]); if (a[mid] &gt; a[right]) swap(&amp;a[mid], &amp;a[right]); //a[left]&gt;=a[right]&gt;=a[mid] //分割时可以直接使用right位置的元素作为基准，而不用改变分割函数了 return a[right];&#125; 分析： 使用三数中值分割法消除了预排序序列有序情况下造成的极大消耗，同时也是对随机数法下有可能出现的小概率事件的完善（当待排序序列有序的情况下随机数法仍然有可能给我们的基准是序列头尾的元素）。当待排序序列都相等时，此中情况下排序的时间复杂度仍为O(N^2)。 代码1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int a[101],n;//定义全局变量，这两个变量需要在子函数中使用void quicksort(int left,int right);int main()&#123; int i,j,t; //读入数据 scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); quicksort(1,n);//快速排序调用 //输出排序后的结果 for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); getchar();getchar(); return 0;&#125;void quicksort(int left,int right)&#123; int i,j,t,temp; if(left&gt;right) return; temp=a[left];//temp中存的就是基准数 i=left; j=right; while (i!=j) &#123; //顺序很重要，要先从右往左找 while(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; //再从左往右找 while(a[i]&lt;=temp &amp;&amp; i&lt;j) i++; //交换两个数在数组中的位置 if(i&lt;j)//当哨兵i和哨兵j没有相遇时 &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=temp; quicksort(left,i-1);//继续处理左边的，这里是一个递归的过程 quicksort(i+1,right);//继续处理右边的，这里是一个递归的过程&#125; https://blog.csdn.net/z_x_m_m_q/article/details/82220884?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-.pc_search_result_before_js&amp;spm=1018.2226.3001.4187 小哼买书例题：输入有 2 行，第 1 行为一个正整数，表示有 n 个同学参与调查（n≤100）。第 2 行有 n个用空格隔开的正整数，为每本图书的ISBN 号（假设图书的 ISBN 号在 1~1000 之间）。输出也是 2 行，第 1 行为一个正整数 k，表示需要买多少本书。第 2 行为 k 个用空格隔开的正整数，为从小到大已排好序的需要购买的图书的 ISBN 号 1.先去重再排序—桶排序12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int a[1001],n,i,t; for(i=1;i&lt;=1000;i++) a[i]=0;//初始化 scanf(&quot;%d&quot;,&amp;n);//读入n for(i=1;i&lt;=n;i++)//循环读入n个图书的ISBN号 &#123; scanf(&quot;%d&quot;,&amp;t);//把每一个ISBN号读到变量t中 a[t]=1;//标记出现过得ISBN号 &#125; for(i=1;i&lt;=1000;i++) //依次判断1~1000这个1000个桶 &#123; if(a[i]==1)//如果这个ISBN号出现过则打印出来 printf(&quot;%d &quot;,i); &#125; getchar();getchar(); return 0; &#125; 2.先排序再去重–冒泡排序或者快速排序接下来，要在输出的时候去掉重复的。因为我们已经排好序，所以相同的数都会紧挨在一起。只要在输出的时候，预先判断一下当前这个数 a[i]与前面一个数 a[i-1]是否相同。如果相同则表示这个数之前已经输出过了，不用再次输出；不同则表示这个数是第一次出现，需要输出这个数。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt; int main() &#123; int a[101],n,i,j,t; scanf(&quot;%d&quot;,&amp;n); //读入n for(i=1;i&lt;=n;i++) //循环读入n个图书ISBN号 &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; //开始冒泡排序 for(i=1;i&lt;=n-1;i++) &#123; for(j=1;j&lt;=n-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; printf(&quot;%d &quot;,a[1]); //输出第1个数 for(i=2;i&lt;=n;i++) //从2循环到n &#123; if( a[i] != a[i-1] ) //如果当前这个数是第一次出现则输出 printf(&quot;%d &quot;,a[i]); &#125; getchar();getchar(); return 0; &#125;","categories":[],"tags":[]},{"title":"Hello World！","slug":"hello-world","date":"2021-06-17T16:27:42.319Z","updated":"2021-06-18T11:19:51.087Z","comments":true,"path":"2021/06/18/hello-world/","link":"","permalink":"https://wxq777.github.io/2021/06/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}